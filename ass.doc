Reflection Report
Submission Info
Name: Levis Ishimwe


Email: i.levis@alustudent.com


GitHub: https://github.com/levishimwe/bookswap


Demo Video: https://www.youtube.com/watch?v=Fb6FazMZJpw


Date: November 9, 2025



BookSwap Firebase Integration â€“ Reflection Document
Student Information
Project: BookSwap â€“ Book Exchange Platform


Course: Individual Assignment 2


Date: November 9, 2025



1. Firebase Integration Experience
Overview
This document reflects on my experience integrating the BookSwap Flutter application with Firebase. It details the challenges faced, the solutions implemented, and the lessons learned while ensuring the app met both functional and academic requirements.

2. Initial Firebase Setup
Challenge 1: Firebase CLI Configuration
Error Encountered:
FirebaseCommandException: 'firebase' is not recognized as an internal or external command

(Screenshot Placeholder: Firebase CLI setup error)
Solution:
Installed Firebase CLI globally using npm:

 npm install -g firebase-tools


Verified the installation and logged in:

 firebase login
flutterfire configure


Lesson Learned:
 Ensure the Firebase CLI is properly installed and configured before linking Flutter projects. Without it, Firebase setup commands will fail.

3. Firebase Authentication Implementation
Challenge 2: Email Verification Not Working
Error Encountered:
PlatformException(ERROR_INVALID_CUSTOM_TOKEN, The custom token format is incorrect)

(Screenshot Placeholder: Email verification setup in Firebase Console)
Solution:
Configured email verification in Firebase Console â†’ Authentication â†’ Templates


Implemented a proper verification flow in Flutter:

 Future<void> sendEmailVerification() async {
  final user = _auth.currentUser;
  if (user != null && !user.emailVerified) {
    await user.sendEmailVerification();
  }
}


Lesson Learned:
 Email verification requires both Firebase Console configuration and client-side handling.

4. Firestore Database Operations
Challenge 3: Permission Denied on Firestore Writes
Error Encountered:
[cloud_firestore/permission-denied]

(Screenshot Placeholder: Firestore rules configuration)
Solution:
 Configured Firestore rules to restrict writes to authenticated users only:
match /books/{bookId} {
  allow read: if true;
  allow create: if request.auth != null;
  allow update, delete: if request.auth.uid == resource.data.ownerId;
}

Lesson Learned:
 Start with strict Firestore rules, then gradually open access while validating authentication conditions.

5. Real-Time Data Synchronization
Challenge 4: StreamBuilder Not Updating
Issue:
 UI did not refresh automatically when Firestore data changed.
(Screenshot Placeholder: StreamBuilder UI not updating)
Solution:
 Used Firestoreâ€™s real-time snapshots() and StreamBuilder:
StreamBuilder<List<BookModel>>(
  stream: bookProvider.getAllBooksStream(),
  builder: (context, snapshot) {
    if (!snapshot.hasData) return CircularProgressIndicator();
    return BookList(books: snapshot.data!);
  },
)

Lesson Learned:
 Use .snapshots() instead of .get() for live updates.

6. Image Storage Strategy
Challenge 5: Firebase Storage Restriction
Error Encountered:
(storage/retry-limit-exceeded)

(Screenshot Placeholder: Upload image failed message)
Solution:
 Used Base64 encoding to store compressed image data in Firestore:
final imageBase64 = base64Encode(compressedBytes);
await _firestore.collection('books').add({'imageBase64': imageBase64});

Displayed using:
Image.memory(base64Decode(book.imageBase64!))

Lesson Learned:
 Base64 image storage is a creative workaround when Firebase Storage or URLs are restricted.

7. State Management with Provider
Challenge 6: UI Not Updating After State Changes
Issue:
 Buttons stayed in loading state even after operations completed.
(Screenshot Placeholder: Provider not rebuilding UI)
Solution:
 Ensured every mutation triggered notifyListeners():
void _setLoading(bool value) {
  _isLoading = value;
  notifyListeners();
}

Lesson Learned:
 Always call notifyListeners() after state changes and use Consumer widgets for automatic rebuilds.

8. Chat Real-Time Messaging
Challenge 7: Messages Not Appearing for Receiver
Issue:
 Receiver had to restart the app to see new messages.
(Screenshot Placeholder: Chat message delay)
Solution:
 Used Firestore subcollection streams:
Stream<List<MessageModel>> getMessages(String chatId) {
  return _firestore.collection('chats').doc(chatId)
    .collection('messages')
    .orderBy('timestamp', descending: true)
    .snapshots()
    .map((snap) => snap.docs.map((d) => MessageModel.fromFirestore(d)).toList());
}

Lesson Learned:
 Firestore subcollections stream real-time updates the same way as root collections.

9. Email Notifications (Mailto Approach)
Challenge 8: Cloud Functions Not Allowed
Constraint:
 Server-side Node.js functions were restricted by the teacher.
Solution:
 Used simple mailto: links instead of server emails:
final mailto = Uri.parse(
  'mailto:${owner.email}?subject=Swap offer for ${book.title}&body=$body'
);
await launchUrl(mailto, mode: LaunchMode.externalApplication);

Lesson Learned:
 Adapting to restrictions can lead to elegant, compliant solutions.

10. Summary of Key Learnings
Area
Key Takeaway
Firebase Setup
Install CLI before running flutterfire configure
Authentication
Requires both backend and frontend setup
Firestore Rules
Use request.auth.uid for ownership checks
Real-time Sync
.snapshots() for continuous updates
Provider
Always call notifyListeners()
Image Storage
Base64 storage + compression for small images
Error Handling
Handle gracefully and log for reference
Testing
Always test on emulator + web
Documentation
Keep structured notes on issues
Adaptation
Be flexible to project constraints


Dart Analyzer Results
Command Run:
dart analyze

Results Summary:
0 Errors


0 Warnings


13 Info messages (mostly .withOpacity() deprecations)


(Screenshot Placeholder: Dart analyzer terminal output)
All info messages are safe to ignore for now and can be fixed in future Flutter SDK updates.

Conclusion
Integrating Firebase with Flutter was both challenging and rewarding.
 Through iterative debugging, I learned to:
Configure Firebase properly using CLI tools,


Apply secure Firestore rules,


Build reactive UIs using Providers and Streams,


Handle platform restrictions with creative, compliant solutions.


The most valuable lesson was adaptability â€” finding functional alternatives like Base64 image storage and mailto: links while maintaining clean architecture and smooth user experience.

Total Development Time: ~20 hours
 Lines of Code: ~4,500 (Dart)
 Firebase Collections: 6 (users, books, swaps, chats, access_requests, action_tokens)
 Screens Implemented: 15+
 State Providers: 7 (Auth, Book, Swap, Chat, Settings, AccessRequest, Users)

ðŸ“˜ Final Note:
 This project strengthened my understanding of full-stack mobile development using Flutter and Firebase â€” covering authentication, database management, state handling, and UI responsiveness â€” while emphasizing disciplined debugging and innovation within constraints.

